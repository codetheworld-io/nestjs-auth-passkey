<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NestJS Passkey Demo</title>
  <style>
      body {
          font-family: sans-serif;
          max-width: 700px;
          margin: 40px auto;
      }

      input, button {
          padding: 8px;
          margin: 4px 0;
          width: 100%;
          box-sizing: border-box;
      }

      section {
          border: 1px solid #ddd;
          padding: 16px;
          margin-bottom: 20px;
      }

      pre {
          background: #f6f6f6;
          padding: 10px;
      }
  </style>
</head>
<body>

<h1>Passkey Auth Demo</h1>

<section>
  <h2>Signup</h2>
  <input id="suUser" placeholder="username" />
  <input id="suPass" type="password" placeholder="password" />
  <button onclick="signup()">Signup</button>
</section>

<section>
  <h2>Signin</h2>
  <input id="siUser" placeholder="username" />
  <input id="siPass" type="password" placeholder="password" />
  <button onclick="signin()">Signin</button>
</section>

<section>
  <h2>Register Passkey</h2>
  <button onclick="registerPasskey()">Register Passkey</button>
</section>

<section>
  <h2>Verify Passkey (Upgrade JWT)</h2>
  <button onclick="loginWithPasskey()">Verify Passkey</button>
</section>

<section>
  <h2>Protected API</h2>
  <button onclick="callProtected()">Call Protected Route</button>
  <pre id="protectedOut"></pre>
</section>

<script>
  const API = 'http://localhost:3000';
  let token = null;

  function setToken(t) {
    token = t;
    console.log('JWT:', token);
  }

  async function callApi(path, method, params) {
    try {
      const response = await fetch(`${API}${path}`, {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { Authorization: 'Bearer ' + token } : {}),
        },
        ...(params ? { body: JSON.stringify(params) } : {}),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}, Response: ${JSON.stringify(data)}`);
      }

      console.log('Api response: ', data);
      return data;

    } catch (error) {
      alert(`Error: ${error.message}`);
      throw error;
    }
  }

  async function signup() {
    const username = suUser.value;
    const password = suPass.value;

    await callApi('/auth/signup', 'POST', { username, password });

    alert('Signup ok');
  }

  async function signin() {
    const username = siUser.value;
    const password = siPass.value;

    const data = await callApi('/auth/signin', 'POST', { username, password });
    setToken(data.accessToken);
    alert('Signed in');
  }

  /* ------------------ PASSKEY REGISTRATION ------------------ */

  async function registerPasskey() {
    try {
      const options = await callApi('/passkeys/register/options', 'GET');

      options.challenge = base64urlToBuffer(options.challenge);
      options.user.id = base64urlToBuffer(options.user.id);
      options.excludeCredentials?.forEach(c => c.id = base64urlToBuffer(c.id));

      const credential = await navigator.credentials.create({ publicKey: options });

      const attestation = {
        id: credential.id,
        rawId: bufferToBase64url(credential.rawId),
        type: credential.type,
        response: {
          clientDataJSON: bufferToBase64url(credential.response.clientDataJSON),
          attestationObject: bufferToBase64url(credential.response.attestationObject),
        },
      };

      await callApi('/passkeys/register/verify', 'POST', attestation);

      alert('Passkey registered');
    } catch (error) {
      alert(`Error: ${error.message}`);
      throw error;
    }
  }

  /* ------------------ PASSKEY AUTH ------------------ */

  async function loginWithPasskey() {
    const options = await callApi('/passkeys/auth/options', 'GET');

    options.challenge = base64urlToBuffer(options.challenge);
    options.allowCredentials.forEach(c => c.id = base64urlToBuffer(c.id));

    const assertion = await navigator.credentials.get({ publicKey: options });

    const attestation = {
      id: assertion.id,
      rawId: bufferToBase64url(assertion.rawId),
      type: assertion.type,
      response: {
        clientDataJSON: bufferToBase64url(assertion.response.clientDataJSON),
        authenticatorData: bufferToBase64url(assertion.response.authenticatorData),
        signature: bufferToBase64url(assertion.response.signature),
        userHandle: assertion.response.userHandle
          ? bufferToBase64url(assertion.response.userHandle)
          : null,
      },
    };

    const data = await callApi('/passkeys/auth/verify', 'POST', attestation);
    setToken(data.accessToken);

    alert('JWT upgraded with passkey');
  }

  /* ------------------ PROTECTED API ------------------ */

  async function callProtected() {
    const data = await callApi('/users/histories', 'GET');

    protectedOut.textContent = JSON.stringify(data);
  }

  /* ------------------ HELPERS ------------------ */
  function bufferToBase64url(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  }

  function base64urlToBuffer(b64) {
    b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
    const pad = b64.length % 4;
    if (pad) b64 += '='.repeat(4 - pad);
    return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  }
</script>

</body>
</html>
